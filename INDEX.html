<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>VR Circuit: High Detail Mode</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #canvas { width: 100%; height: 100vh; display: block; }
        #vrButton { position: absolute; bottom: 20px; left: 20px; z-index: 100; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="vrButton"></div>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
        import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/webxr/VRButton.js';

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2c3e50); 
        scene.fog = new THREE.Fog(0xf39c12, 5, 40);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 4);
        
        // Sharpness Change: Enabled antialias in the constructor
        const renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('canvas') });
        
        // Sharpness Change: renderer.setPixelRatio ensures the 3D scene matches high-res screens (Retina/4K)
        renderer.setPixelRatio(window.devicePixelRatio);
        
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.shadowMap.enabled = true;
        document.getElementById('vrButton').appendChild(VRButton.createButton(renderer));

        // --- EVENING LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0x483d8b, 0.4); 
        scene.add(ambientLight);
        const sunsetLight = new THREE.DirectionalLight(0xffa500, 1.5);
        sunsetLight.position.set(-10, 5, -5); 
        sunsetLight.castShadow = true;
        scene.add(sunsetLight);
        const hemiLight = new THREE.HemisphereLight(0x483d8b, 0x3d2b1f, 0.5);
        scene.add(hemiLight);

        // --- GROUND & TABLE ---
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ color: 0x1a0f0a }));
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        const tableGroup = new THREE.Group();
        const tableMat = new THREE.MeshStandardMaterial({ color: 0x3e2723, roughness: 0.6 });
        const top = new THREE.Mesh(new THREE.BoxGeometry(5, 0.2, 2.5), tableMat);
        top.position.y = 1.0; top.castShadow = true; top.receiveShadow = true;
        tableGroup.add(top);
        [[-2.3,-1.1], [2.3,-1.1], [-2.3,1.1], [2.3,1.1]].forEach(p => {
            const leg = new THREE.Mesh(new THREE.BoxGeometry(0.2, 1.0, 0.2), tableMat);
            leg.position.set(p[0], 0.5, p[1]);
            leg.castShadow = true;
            tableGroup.add(leg);
        });
        tableGroup.position.z = -3;
        scene.add(tableGroup);

        const surfaceY = 1.1;

        // --- DYNAMIC LABEL ---
        const batCanvas = document.createElement('canvas');
        
        // Sharpness Change: Increased internal canvas dimensions by 5x (256*5 and 90*5)
        const labelScale = 9;
        batCanvas.width = 256 * labelScale; 
        batCanvas.height = 90 * labelScale;
        
        const batCtx = batCanvas.getContext('2d');
        
        // Sharpness Change: Scaling the context so text looks high-definition
        batCtx.scale(labelScale, labelScale);

        const batTexture = new THREE.CanvasTexture(batCanvas);
        
        // Sharpness Change: Anisotropy keeps the text sharp when viewed from an angle
        batTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

        const batSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: batTexture }));
        batSprite.position.set(-1.8, surfaceY + 0.9, -3);
        batSprite.scale.set(0.8, 0.3, 1);
        scene.add(batSprite);

        function updateBatteryLabel(level) {
            batCtx.clearRect(0, 0, 256, 90);
            batCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            batCtx.beginPath(); // Added for cleaner rounding
            batCtx.roundRect(0, 0, 256, 90, 15);
            batCtx.fill();
            batCtx.font = 'bold 32px Arial';
            batCtx.fillStyle = 'black';
            batCtx.textAlign = 'center';
            batCtx.fillText("BATTERY: " + Math.ceil(level) + "%", 128, 55);
            batTexture.needsUpdate = true;
        }

        // --- COMPONENTS ---
        let batteryLevel = 100;
        const battery = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.4), new THREE.MeshStandardMaterial({ color: 0x111111 }));
        battery.position.set(-1.8, surfaceY + 0.3, -3);
        battery.castShadow = true;
        scene.add(battery);

        const switchMesh = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.4), new THREE.MeshStandardMaterial({ color: 0x2c3e50 }));
        switchMesh.position.set(0, surfaceY + 0.1, -3);
        switchMesh.castShadow = true;
        scene.add(switchMesh);

        const bulbGroup = new THREE.Group();
        // Sharpness Change: Increased SphereGeometry segments from 32 to 64 for a smoother glass look
        const glass = new THREE.Mesh(new THREE.SphereGeometry(0.25, 64, 64), new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.1, roughness: 0 }));
        const filament = new THREE.Mesh(new THREE.TorusKnotGeometry(0.06, 0.01, 64, 8), new THREE.MeshBasicMaterial({ color: 0x222222 }));
        const bulbLight = new THREE.PointLight(0xffcc00, 0, 15);
        bulbLight.castShadow = true;
        const base = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.2), new THREE.MeshStandardMaterial({ color: 0x111111 }));
        base.position.y = -0.25;
        bulbGroup.add(glass, filament, base, bulbLight);
        bulbGroup.position.set(1.8, surfaceY + 0.3, -3);
        scene.add(bulbGroup);

        const resetBtn = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.05), new THREE.MeshStandardMaterial({ color: 0x922b21 }));
        resetBtn.position.set(-1.8, surfaceY + 0.05, -2.2);
        scene.add(resetBtn);

        // --- WIRE & CURRENT ---
        const curve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(-1.4, surfaceY + 0.1, -3),
            new THREE.Vector3(1.68, surfaceY + 0.1, -3)
        ]);
        const wire = new THREE.Mesh(new THREE.TubeGeometry(curve, 64, 0.02, 8, false), new THREE.MeshStandardMaterial({ color: 0x050505 }));
        scene.add(wire);

        const particleCount = 40;
        const particleGeo = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        particleGeo.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        const currentPoints = new THREE.Points(particleGeo, new THREE.PointsMaterial({ color: 0xff3300, size: 0.06 }));
        scene.add(currentPoints);
        const offsets = Array.from({ length: particleCount }, () => Math.random());

        // --- ANIMATION ---
        let currentOn = false;
        window.addEventListener('click', (event) => {
            const mouse = new THREE.Vector2((event.clientX/window.innerWidth)*2-1, -(event.clientY/window.innerHeight)*2+1);
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            if (raycaster.intersectObject(switchMesh).length > 0 && batteryLevel > 0) {
                currentOn = !currentOn;
                switchMesh.material.color.setHex(currentOn ? 0xf1c40f : 0x2c3e50); 
                bulbLight.intensity = currentOn ? 3 : 0;
                filament.material.color.setHex(currentOn ? 0xffea00 : 0x222222);
            }
            if (raycaster.intersectObject(resetBtn).length > 0) batteryLevel = 100;
        });

        renderer.setAnimationLoop(() => {
            if (currentOn && batteryLevel > 0) {
                batteryLevel -= 0.05;
                const d = batteryLevel / 100;
                bulbLight.intensity = 3 * d;
                filament.material.color.setRGB(d, d * 0.8, 0);
                
                for (let i = 0; i < particleCount; i++) {
                    offsets[i] = (offsets[i] + 0.005) % 1.0;
                    const p = curve.getPoint(offsets[i]);
                    particlePositions[i*3] = p.x; particlePositions[i*3+1] = p.y+0.05; particlePositions[i*3+2] = p.z;
                }
                particleGeo.attributes.position.needsUpdate = true;
                currentPoints.visible = true;

                if (batteryLevel <= 0) { 
                    currentOn = false; 
                    bulbLight.intensity = 0; 
                    switchMesh.material.color.setHex(0x2c3e50);
                    filament.material.color.setHex(0x222222);
                }
            } else { currentPoints.visible = false; }
            updateBatteryLabel(batteryLevel);
            renderer.render(scene, camera);
        });
    </script>
</body>
</html>
