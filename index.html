<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>VR 3D Circuit: Battery, Switch, Light</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #canvas { width: 100%; height: 100vh; display: block; }
        #vrButton { position: absolute; bottom: 20px; left: 20px; z-index: 100; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <button id="vrButton">Enter VR</button>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
        import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/webxr/VRButton.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 0);
        const renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('canvas') });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;

        // Add VR button
        document.getElementById('vrButton').appendChild(VRButton.createButton(renderer));

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        // Battery
        const batteryGeometry = new THREE.BoxGeometry(0.8, 1, 0.4);
        const batteryMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
        const battery = new THREE.Mesh(batteryGeometry, batteryMaterial);
        battery.position.set(-2, 1.6, -3);
        scene.add(battery);

        // Switch
        const switchGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        const switchMaterial = new THREE.MeshPhongMaterial({ color: 0x888888 });
        const switchMesh = new THREE.Mesh(switchGeometry, switchMaterial);
        switchMesh.position.set(0, 1.6, -3);
        scene.add(switchMesh);

        // Light (bulb)
        const bulbGeometry = new THREE.SphereGeometry(0.3, 32, 32);
        const bulbMaterial = new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0x000000 });
        const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
        bulb.position.set(2, 1.6, -3);
        scene.add(bulb);

        // Wire path from battery -> switch -> light
        const wireMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
        const wirePoints = [
            new THREE.Vector3(-2, 1.6, -3), // Battery
            new THREE.Vector3(-1, 1.6, -3),
            new THREE.Vector3( 0, 1.6, -3), // Switch
            new THREE.Vector3( 1, 1.6, -3),
            new THREE.Vector3( 2, 1.6, -3)  // Light
        ];
        const wireGeometry = new THREE.BufferGeometry().setFromPoints(wirePoints);
        const wire = new THREE.Line(wireGeometry, wireMaterial);
        scene.add(wire);

        // Build a list of evenly spaced positions along the wire for current particles
        function samplePath(points, samples) {
            const pathPositions = [];
            for (let i = 0; i < points.length - 1; i++) {
                const start = points[i];
                const end   = points[i + 1];
                for (let j = 0; j < samples; j++) {
                    const t = j / samples;
                    const x = start.x + (end.x - start.x) * t;
                    const y = start.y + (end.y - start.y) * t;
                    const z = start.z + (end.z - start.z) * t;
                    pathPositions.push(new THREE.Vector3(x, y, z));
                }
            }
            return pathPositions;
        }

        const pathPositions = samplePath(wirePoints, 10); // total positions along wire
        const particleCount = 40;
        const particlePositions = new Float32Array(particleCount * 3);
        const particleGeometry = new THREE.BufferGeometry();
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        const particleMaterial = new THREE.PointsMaterial({ color: 0xff0000, size: 0.06 });
        const currentPoints = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(currentPoints);

        // Initialize each particle at a random point along the path
        const offsets = [];
        for (let i = 0; i < particleCount; i++) {
            const idx = Math.floor(Math.random() * pathPositions.length);
            offsets.push(idx);
            const p = pathPositions[idx];
            particlePositions[i * 3]     = p.x;
            particlePositions[i * 3 + 1] = p.y;
            particlePositions[i * 3 + 2] = p.z;
        }
        particleGeometry.attributes.position.needsUpdate = true;

        let currentOn = false;

        // Interaction (click switch)
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        window.addEventListener('click', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([switchMesh]);
            if (intersects.length > 0) {
                // Toggle switch color
                const isOff = switchMesh.material.color.getHex() === 0x888888;
                switchMesh.material.color.setHex(isOff ? 0xff0000 : 0x888888);

                // Toggle bulb
                bulb.material.emissive.setHex(isOff ? 0xffff00 : 0x000000);

                // Toggle current
                currentOn = isOff;
            }
        });

        // Resize handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop: move particles when currentOn == true
        function animate() {
            renderer.setAnimationLoop(() => {
                if (currentOn) {
                    for (let i = 0; i < particleCount; i++) {
                        offsets[i] = (offsets[i] + 0.3) % pathPositions.length;
                        const idx = Math.floor(offsets[i]);
                        const p = pathPositions[idx];
                        particlePositions[i * 3]     = p.x;
                        particlePositions[i * 3 + 1] = p.y;
                        particlePositions[i * 3 + 2] = p.z;
                    }
                    particleGeometry.attributes.position.needsUpdate = true;
                }
                renderer.render(scene, camera);
            });
        }
        animate();
    </script>
</body>
</html>
